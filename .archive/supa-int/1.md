# Supabase Integration in bolt.diy

## Overview

bolt.diy implements Supabase integration to enable users to easily incorporate Supabase databases into their applications. This integration is meta in nature - it's not about using Supabase for bolt.diy itself, but rather about helping the applications built with bolt.diy to connect to and use Supabase effectively.

## Architecture

The Supabase integration follows a layered architecture:

1. **UI Layer**: Connection management, project selection, and credentials storage
2. **API Layer**: Endpoints for fetching projects, executing queries, and retrieving API keys
3. **Action Layer**: Runtime handling of Supabase-specific actions from the LLM
4. **Prompt Layer**: Instruction templates to guide the LLM in proper Supabase implementation

## Core Components

### 1. Supabase Types (`app/types/supabase.ts`)

Defines the data structures for Supabase integration:

```typescript
export interface SupabaseUser {
  id: string;
  email: string;
  role: string;
  created_at: string;
  last_sign_in_at: string;
}

export interface SupabaseProject {
  id: string;
  name: string;
  organization_id: string;
  region: string;
  created_at: string;
  status: string;
}

export interface SupabaseCredentials {
  anonKey?: string;
  supabaseUrl?: string;
}
```

### 2. Supabase Store (`app/lib/stores/supabase.ts`)

Manages the global state related to Supabase connections:

- Stores connection state (user, token, selected project)
- Persists credentials in localStorage
- Provides methods for fetching projects and API keys
- Handles connection and project selection

### 3. API Routes

- **`api.supabase.ts`**: Fetches Supabase projects using the user's API token
- **`api.supabase.query.ts`**: Executes SQL queries against a selected Supabase project
- **`api.supabase.variables.ts`**: Retrieves API keys for a selected project

### 4. Supabase Actions

The `ActionRunner` class in `app/lib/runtime/action-runner.ts` processes Supabase actions:

- **Migration Actions**: Create migration files in the project structure
- **Query Actions**: Execute SQL queries against the selected Supabase project

### 5. Connection Hook (`app/lib/hooks/useSupabaseConnection.ts`)

A React hook that provides components with access to:
- Connection state
- Connection/disconnection methods
- Project selection functionality
- API key management

## Prompt System Integration

The most critical part of the Supabase integration is how it's incorporated into the LLM prompt system. This guides the AI in properly implementing Supabase in generated applications.

### Key Prompt Instructions

1. **Database Preference**:
   ```
   CRITICAL: Use Supabase for databases by default, unless specified otherwise.
   ```

2. **Connection Checking**:
   ```
   IMPORTANT NOTE: Supabase project setup and configuration is handled separately by the user!
   ```
   
   The system checks if the user is connected to Supabase and has selected a project, prompting them to do so if not.

3. **Environment Variables**:
   ```
   VITE_SUPABASE_URL=${supabase.credentials.supabaseUrl}
   VITE_SUPABASE_ANON_KEY=${supabase.credentials.anonKey}
   ```
   
   When credentials are available, the system instructs the LLM to include them in the .env file.

4. **Migration Guidelines**:
   - Create migration files in `/supabase/migrations/`
   - Never modify existing migrations
   - Always enable Row Level Security (RLS)
   - Add appropriate policies for CRUD operations
   - Include comprehensive markdown documentation in each migration

5. **Client Setup**:
   ```
   - Use `@supabase/supabase-js`
   - Create a singleton client instance
   - Use the environment variables from the project's `.env` file
   ```

6. **Authentication Guidelines**:
   ```
   - ALWAYS use email and password sign up
   - FORBIDDEN: NEVER create your own authentication system or authentication table
   - ALWAYS use Supabase's built-in authentication!
   ```

7. **Action Format**:
   For each database change, provide both a migration file and an immediate query:
   
   ```
   <boltAction type="supabase" operation="migration" filePath="/supabase/migrations/your_migration.sql">
     /* SQL migration content */
   </boltAction>

   <boltAction type="supabase" operation="query" projectId="${projectId}">
     /* Same SQL content as migration */
   </boltAction>
   ```

### SQL Best Practices

The prompts enforce several SQL best practices:

1. **Data Safety**:
   - Never use destructive operations that could result in data loss
   - Avoid explicit transaction management

2. **Defensive SQL**:
   - Use `IF EXISTS` or `IF NOT EXISTS` clauses
   - Use PL/pgSQL anonymous blocks for conditional operations

3. **Documentation**:
   - Each migration must include a markdown summary
   - Document all tables, columns, and security policies

## Runtime Implementation

When the LLM generates a Supabase action:

1. The `StreamingMessageParser` parses the action and extracts operation, content, and filePath
2. The `ActionRunner.handleSupabaseAction` method processes the action:
   - For migration actions: Creates a file in the specified path
   - For query actions: Shows an alert allowing the user to execute the query

The query execution actually happens via the UI, not automatically. This provides a safeguard for the user to review queries before they affect their database.

## Security Considerations

1. **API Keys**: User's Supabase API keys are stored in localStorage and transmitted securely
2. **Query Review**: SQL queries are shown to users for approval before execution
3. **Row Level Security**: The system strongly emphasizes using RLS for all tables
4. **Authentication**: Built-in Supabase authentication is mandated

## Best Practices for Generated Applications

The prompt system enforces several best practices for Supabase usage:

1. **Client Structure**:
   - Use a singleton client pattern
   - Store credentials in environment variables

2. **Database Design**:
   - Enable RLS on all tables
   - Create appropriate policies
   - Use UUIDs for primary keys
   - Set sensible default values

3. **Migration Pattern**:
   - Create individual migration files for each change
   - Never modify existing migrations
   - Include comprehensive documentation

4. **Authentication**:
   - Use Supabase's built-in auth system
   - Default to email/password authentication

## Limitations

1. The system cannot use the Supabase CLI due to WebContainer limitations
2. Type generation for Supabase is not supported
3. Magic links, social auth, and SSO are not supported by default
4. **Storage bucket integration is missing**, which is a significant gap for modern web applications

## Implementation Plan for Supabase Storage Integration

### 1. Extending Prompts with Storage Bucket Best Practices

The prompt system should be enhanced to include guidance for Supabase storage implementations. Here's a draft for the storage section to add to the prompt system:

```typescript
<storage_instructions>
  The following instructions guide how you should handle file storage operations in projects.
  
  CRITICAL: Use Supabase Storage for file uploads and storage needs unless specified otherwise.
  
  Bucket Management:
    - Create buckets with proper permissions (public or private based on use case)
    - For private buckets, implement Row Level Security (RLS) policies
    - For public buckets, ensure proper file validation to prevent security issues
    - Follow a consistent naming convention for buckets (e.g., 'avatars', 'documents', 'media')
    
  File Upload Best Practices:
    - ALWAYS validate files on the client-side before uploading (type, size, content)
    - CRITICAL: Set appropriate file size limits for buckets
    - ALWAYS specify allowed MIME types for each bucket
    - Generate unique filenames to prevent collisions (UUID + original extension)
    - RECOMMENDED: Store metadata about uploaded files in database tables
    
  Security Considerations:
    - NEVER allow unrestricted file uploads without validation
    - For private files, check user permissions before allowing downloads
    - For image uploads, consider using Supabase's image transformation features
    - ALWAYS handle file upload errors gracefully with user feedback
    
  Implementation Pattern:
    For file operations, follow this pattern:
    
    1. Create appropriate buckets during application initialization
    2. Implement proper RLS policies for buckets
    3. Use the storage client for uploads, downloads, and listing operations
    4. Handle transformations for images when needed
    
  Example Storage Client Setup:
  ```javascript
  // Initialize Supabase client
  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
  const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY
  const supabase = createClient(supabaseUrl, supabaseKey)
  
  // Usage example for uploads
  const { data, error } = await supabase.storage
    .from('avatars')
    .upload('profile-123.png', file, {
      cacheControl: '3600',
      upsert: false,
      contentType: 'image/png'
    })
  ```
  
  File Operations Guidelines:
  - For uploads, always include proper contentType and cacheControl
  - For downloads, use signed URLs for private files
  - For public files, use public URLs with CDN benefits
  - For listing files, paginate results for performance
  
  Storage Bucket Policies:
  - Create SQL migration files for bucket RLS policies
  - Example RLS policy for allowing users to access only their own files:
  
  ```sql
  -- Allow users to select their own files
  CREATE POLICY "Users can view their own files"
    ON storage.objects
    FOR SELECT
    TO authenticated
    USING (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text);
  
  -- Allow users to upload their own files
  CREATE POLICY "Users can upload their own files"
    ON storage.objects
    FOR INSERT
    TO authenticated
    WITH CHECK (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text);
  ```
</storage_instructions>
```

### 2. API Endpoints for Bucket Operations

Implement new API endpoints to handle Supabase storage operations:

#### 2.1. `api.supabase.storage.ts`

This endpoint would handle storage-related operations including:

```typescript
// api.supabase.storage.ts
import { json, type ActionFunctionArgs } from '@remix-run/cloudflare';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('api.supabase.storage');

export async function action({ request }: ActionFunctionArgs) {
  if (request.method !== 'POST') {
    return json({ error: 'Method not allowed' }, { status: 405 });
  }

  const authHeader = request.headers.get('Authorization');
  if (!authHeader) {
    return json({ error: 'No authorization token provided' }, { status: 401 });
  }

  try {
    const { operation, projectId, bucketName, filePath, fileData, options } = await request.json();
    logger.debug('Storage operation:', { operation, projectId, bucketName, filePath });

    // Route to appropriate handler based on operation
    switch (operation) {
      case 'createBucket':
        return handleCreateBucket(authHeader, projectId, bucketName, options);
      case 'listBuckets':
        return handleListBuckets(authHeader, projectId);
      case 'getBucket':
        return handleGetBucket(authHeader, projectId, bucketName);
      case 'uploadFile':
        return handleUploadFile(authHeader, projectId, bucketName, filePath, fileData, options);
      case 'downloadFile':
        return handleDownloadFile(authHeader, projectId, bucketName, filePath);
      case 'listFiles':
        return handleListFiles(authHeader, projectId, bucketName, options);
      case 'getPublicUrl':
        return handleGetPublicUrl(projectId, bucketName, filePath);
      default:
        return json({ error: `Unknown operation: ${operation}` }, { status: 400 });
    }
  } catch (error) {
    logger.error('Storage operation error:', error);
    return json(
      { error: error instanceof Error ? error.message : 'Operation failed' },
      { status: 500 }
    );
  }
}

// Implement handler functions for each operation...
```

#### 2.2. `api.supabase.storage.policy.ts`

A dedicated endpoint for managing storage bucket policies:

```typescript
// api.supabase.storage.policy.ts
import { json, type ActionFunctionArgs } from '@remix-run/cloudflare';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('api.supabase.storage.policy');

export async function action({ request }: ActionFunctionArgs) {
  // Implementation for creating and managing bucket policies
  // ...
}
```

### 3. Action Handlers for Storage Operations

Extend the existing `ActionRunner` to handle Supabase storage actions:

```typescript
// Update in app/lib/runtime/action-runner.ts

async handleSupabaseAction(action: SupabaseAction) {
  const { operation, content, filePath, bucketName, fileData, options } = action;
  logger.debug('[Supabase Action]:', { operation, filePath, bucketName });

  switch (operation) {
    // Existing cases for 'migration' and 'query'
    
    case 'createBucket':
      // Alert for bucket creation
      this.onSupabaseAlert?.({  
        type: 'info',
        title: 'Supabase Storage',
        description: `Create bucket: ${bucketName}`,
        content: JSON.stringify(options, null, 2),
        source: 'supabase',
      });
      return { pending: true };
      
    case 'uploadFile':
      // Alert for file upload
      this.onSupabaseAlert?.({  
        type: 'info',
        title: 'Supabase Storage',
        description: `Upload file to ${bucketName}: ${filePath}`,
        content: JSON.stringify(options, null, 2),
        source: 'supabase',
      });
      return { pending: true };
      
    case 'storagePolicy':
      // Alert for storage policy
      this.onSupabaseAlert?.({  
        type: 'info',
        title: 'Supabase Storage Policy',
        description: `Create policy for bucket: ${bucketName}`,
        content,
        source: 'supabase',
      });
      
      // Create the migration file
      await this.#runFileAction({
        type: 'file',
        filePath: filePath || `/supabase/migrations/storage_${bucketName}_policy.sql`,
        content,
        changeSource: 'supabase',
      } as any);
      return { success: true };
      
    // Add more cases for other storage operations
      
    default:
      throw new Error(`Unknown operation: ${operation}`);
  }
}
```

### 4. Types and Interfaces

Update the type definitions to support storage operations:

```typescript
// Update in app/types/actions.ts
export interface SupabaseAction extends BaseAction {
  type: 'supabase';
  operation: 'migration' | 'query' | 'createBucket' | 'uploadFile' | 'downloadFile' | 'listFiles' | 'storagePolicy';
  content?: string;
  filePath?: string;
  bucketName?: string;
  fileData?: string; // Base64 encoded file data
  options?: Record<string, any>;
}

// Update in app/types/supabase.ts
export interface SupabaseBucket {
  id: string;
  name: string;
  public: boolean;
  created_at: string;
  updated_at: string;
  owner: string;
  file_size_limit?: number;
  allowed_mime_types?: string[];
}

export interface SupabaseStorageFile {
  name: string;
  id: string;
  updated_at: string;
  created_at: string;
  last_accessed_at: string;
  metadata: Record<string, any>;
  bucketId: string;
  owner: string;
  size: number;
  mimetype: string;
}
```

### 5. UI Components for Storage Management

Create new UI components for visualizing and managing storage operations:

```typescript
// app/components/chat/SupabaseStorageAlert.tsx
import React, { useState } from 'react';
import { useStore } from '@nanostores/react';
import { supabaseConnection } from '~/lib/stores/supabase';
import { Button, Dialog } from '~/components/ui';
import type { SupabaseAlert } from '~/types/actions';

interface SupabaseStorageAlertProps {
  alert: SupabaseAlert;
  onClose: () => void;
  onExecute: () => void;
}

export default function SupabaseStorageAlert({
  alert,
  onClose,
  onExecute,
}: SupabaseStorageAlertProps) {
  const connection = useStore(supabaseConnection);
  const [isExecuting, setIsExecuting] = useState(false);
  
  // Component implementation
  // ...
}
```

### 6. Client-Side Hooks

Create a dedicated hook for storage operations:

```typescript
// app/lib/hooks/useSupabaseStorage.ts
import { useState, useCallback } from 'react';
import { useStore } from '@nanostores/react';
import { supabaseConnection } from '~/lib/stores/supabase';
import { toast } from 'react-toastify';

export function useSupabaseStorage() {
  const connection = useStore(supabaseConnection);
  const [isLoading, setIsLoading] = useState(false);
  
  const createBucket = useCallback(async (bucketName: string, options?: any) => {
    // Implementation
    // ...
  }, [connection]);
  
  const listBuckets = useCallback(async () => {
    // Implementation
    // ...
  }, [connection]);
  
  // More methods for storage operations
  
  return {
    createBucket,
    listBuckets,
    // ... other methods
    isLoading,
  };
}
```

### 7. Best Practices for Storage Implementation

Based on the Supabase documentation and best practices, here are key recommendations for storage integration:

#### 7.1. Security Best Practices

1. **Bucket Access Control**:
   - Use public buckets only for content that should be publicly accessible
   - Use private buckets with RLS policies for protected content
   - Use folder structures to organize files by user ID or resource ID

2. **File Validation**:
   - Validate file types, sizes, and contents on both client and server
   - Use the `allowed_mime_types` option when creating buckets
   - Set appropriate `file_size_limit` for each bucket

3. **Row Level Security**:
   - Create policies that restrict access based on user ID
   - Use `storage.foldername()` function to extract path segments
   - Implement different policies for SELECT, INSERT, UPDATE, and DELETE

#### 7.2. Performance Considerations

1. **File Organization**:
   - Use hierarchical folder structures for better organization
   - Consider using UUID-based filenames to prevent collisions
   - Implement pagination for file listings

2. **Image Optimization**:
   - Use Supabase's image transformation features for resizing and optimizing images
   - Implement client-side image compression before upload
   - Consider using different buckets for different types of media

3. **Caching Strategies**:
   - Set appropriate `cacheControl` when uploading files
   - Use CDN URLs for public files
   - Implement client-side caching for frequently accessed files

#### 7.3. Implementation Examples

**Creating a bucket with restrictions**:
```javascript
const { data, error } = await supabase.storage.createBucket('avatars', {
  public: false,
  allowedMimeTypes: ['image/png', 'image/jpeg', 'image/gif'],
  fileSizeLimit: 1024 * 1024, // 1MB
})
```

**Uploading files with user-specific paths**:
```javascript
const userId = supabase.auth.user().id;
const filePath = `${userId}/${fileName}`;

const { data, error } = await supabase.storage
  .from('documents')
  .upload(filePath, file, {
    cacheControl: '3600',
    upsert: false,
    contentType: 'application/pdf'
  })
```

**Creating RLS policies for buckets**:
```sql
-- Allow users to view their own files
CREATE POLICY "Users can view their own files"
ON storage.objects
FOR SELECT
TO authenticated
USING (bucket_id = 'documents' AND auth.uid()::text = (storage.foldername(name))[1]);

-- Allow users to upload their own files
CREATE POLICY "Users can upload their own files"
ON storage.objects
FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'documents' AND auth.uid()::text = (storage.foldername(name))[1]);
```

## Conclusion

bolt.diy's Supabase integration provides a comprehensive framework for the LLM to generate applications with proper Supabase database integration. It combines:

1. UI for managing connections and projects
2. API endpoints for interacting with Supabase
3. Action handling for executing migrations and queries
4. Detailed prompt guidelines for proper implementation

The proposed storage bucket integration would significantly enhance this foundation by adding support for file uploads, downloads, and management. By implementing these features, bolt.diy would provide a complete Supabase integration covering both database and storage needs, making it a more powerful tool for building modern web applications.

## Step-by-Step Integration Guide

Based on the bolt.diy codebase structure, here's a practical implementation guide for adding Supabase storage bucket support:

### Step 1: Define Types and Interfaces

1. Create or update the Supabase types in `app/types/supabase.ts`:

```typescript
// Add these interfaces to app/types/supabase.ts
export interface SupabaseBucket {
  id: string;
  name: string;
  public: boolean;
  created_at: string;
  updated_at: string;
  owner: string;
  file_size_limit?: number;
  allowed_mime_types?: string[];
}

export interface SupabaseStorageFile {
  name: string;
  id: string;
  updated_at: string;
  created_at: string;
  last_accessed_at: string;
  metadata: Record<string, any>;
  bucketId: string;
  owner: string;
  size: number;
  mimetype: string;
}
```

2. Update the action types in `app/types/actions.ts`:

```typescript
// Update the SupabaseAction interface in app/types/actions.ts
export interface SupabaseAction extends BaseAction {
  type: 'supabase';
  operation: 'migration' | 'query' | 'createBucket' | 'uploadFile' | 'downloadFile' | 'listFiles' | 'storagePolicy';
  content?: string;
  filePath?: string;
  bucketName?: string;
  fileData?: string; // Base64 encoded file data
  options?: Record<string, any>;
}

// Also update the SupabaseAlert interface if needed
export interface SupabaseAlert {
  type: 'info' | 'success' | 'error' | 'warning';
  title: string;
  description: string;
  content: string;
  source?: 'supabase';
  operation?: 'migration' | 'query' | 'storage';
}
```

### Step 2: Implement API Endpoints

1. Create `app/routes/api.supabase.storage.ts`:

```typescript
import { json, type ActionFunctionArgs } from '@remix-run/cloudflare';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('api.supabase.storage');

export async function action({ request }: ActionFunctionArgs) {
  if (request.method !== 'POST') {
    return json({ error: 'Method not allowed' }, { status: 405 });
  }

  const authHeader = request.headers.get('Authorization');
  if (!authHeader) {
    return json({ error: 'No authorization token provided' }, { status: 401 });
  }

  try {
    const { operation, projectId, bucketName, filePath, fileData, options } = await request.json();
    logger.debug('Storage operation:', { operation, projectId, bucketName, filePath });

    // Route to appropriate handler based on operation
    switch (operation) {
      case 'createBucket':
        return await handleCreateBucket(authHeader, projectId, bucketName, options);
      case 'listBuckets':
        return await handleListBuckets(authHeader, projectId);
      case 'getBucket':
        return await handleGetBucket(authHeader, projectId, bucketName);
      case 'uploadFile':
        return await handleUploadFile(authHeader, projectId, bucketName, filePath, fileData, options);
      case 'downloadFile':
        return await handleDownloadFile(authHeader, projectId, bucketName, filePath);
      case 'listFiles':
        return await handleListFiles(authHeader, projectId, bucketName, options);
      case 'getPublicUrl':
        return handleGetPublicUrl(projectId, bucketName, filePath);
      default:
        return json({ error: `Unknown operation: ${operation}` }, { status: 400 });
    }
  } catch (error) {
    logger.error('Storage operation error:', error);
    return json(
      { error: error instanceof Error ? error.message : 'Operation failed' },
      { status: 500 }
    );
  }
}

async function handleCreateBucket(authHeader: string, projectId: string, bucketName: string, options?: any) {
  try {
    const response = await fetch(`https://api.supabase.com/v1/projects/${projectId}/storage/buckets`, {
      method: 'POST',
      headers: {
        Authorization: authHeader,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: bucketName,
        public: options?.public ?? false,
        file_size_limit: options?.fileSizeLimit,
        allowed_mime_types: options?.allowedMimeTypes,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      logger.error('Bucket creation failed:', errorText);
      return json({ error: 'Failed to create bucket' }, { status: response.status });
    }

    const data = await response.json();
    return json({ data });
  } catch (error) {
    logger.error('Bucket creation error:', error);
    return json({ error: 'Failed to create bucket' }, { status: 500 });
  }
}

// Implement other handler functions for different operations
// ...
```

2. Create `app/routes/api.supabase.storage.policy.ts` for bucket policies:

```typescript
import { json, type ActionFunctionArgs } from '@remix-run/cloudflare';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('api.supabase.storage.policy');

export async function action({ request }: ActionFunctionArgs) {
  if (request.method !== 'POST') {
    return json({ error: 'Method not allowed' }, { status: 405 });
  }

  const authHeader = request.headers.get('Authorization');
  if (!authHeader) {
    return json({ error: 'No authorization token provided' }, { status: 401 });
  }

  try {
    const { projectId, bucketName, policyName, definition } = await request.json();
    
    // Implementation for creating bucket policies
    // This would make API calls to Supabase to create/manage policies
    
    return json({ success: true });
  } catch (error) {
    logger.error('Storage policy error:', error);
    return json({ error: 'Failed to manage policy' }, { status: 500 });
  }
}
```

### Step 3: Extend the Supabase Store

Update `app/lib/stores/supabase.ts` to include storage-related state:

```typescript
// Add to the existing SupabaseConnectionState interface
export interface SupabaseConnectionState {
  // Existing properties...
  storageBuckets?: SupabaseBucket[];
  selectedBucketId?: string;
}

// Add storage-related functions
export async function fetchStorageBuckets(token: string, projectId: string) {
  if (!token || !projectId) return;
  
  try {
    isFetchingBuckets.set(true);
    
    const response = await fetch('/api/supabase/storage', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({
        operation: 'listBuckets',
        projectId,
      }),
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch buckets');
    }
    
    const { data } = await response.json();
    
    // Update state with buckets
    updateSupabaseConnection({
      storageBuckets: data,
    });
    
    return data;
  } catch (error) {
    console.error('Error fetching buckets:', error);
  } finally {
    isFetchingBuckets.set(false);
  }
}

// Add a new atom for tracking bucket loading state
export const isFetchingBuckets = atom(false);
```

### Step 4: Create a Hook for Storage Operations

Create `app/lib/hooks/useSupabaseStorage.ts`:

```typescript
import { useState, useCallback } from 'react';
import { useStore } from '@nanostores/react';
import { supabaseConnection, updateSupabaseConnection, isFetchingBuckets } from '~/lib/stores/supabase';
import { toast } from 'react-toastify';
import type { SupabaseBucket, SupabaseStorageFile } from '~/types/supabase';

export function useSupabaseStorage() {
  const connection = useStore(supabaseConnection);
  const fetchingBuckets = useStore(isFetchingBuckets);
  const [isLoading, setIsLoading] = useState(false);
  
  const refreshBuckets = useCallback(async () => {
    if (!connection.token || !connection.selectedProjectId) {
      toast.error('No Supabase connection or project selected');
      return;
    }
    
    try {
      await fetchStorageBuckets(connection.token, connection.selectedProjectId);
    } catch (error) {
      console.error('Failed to refresh buckets:', error);
      toast.error('Failed to refresh buckets');
    }
  }, [connection]);
  
  const createBucket = useCallback(async (bucketName: string, options?: any) => {
    if (!connection.token || !connection.selectedProjectId) {
      toast.error('No Supabase connection or project selected');
      return null;
    }
    
    setIsLoading(true);
    
    try {
      const response = await fetch('/api/supabase/storage', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          operation: 'createBucket',
          projectId: connection.selectedProjectId,
          bucketName,
          options,
        }),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to create bucket');
      }
      
      const { data } = await response.json();
      toast.success(`Bucket ${bucketName} created successfully`);
      
      // Refresh buckets list
      await refreshBuckets();
      
      return data;
    } catch (error) {
      console.error('Bucket creation error:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create bucket');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [connection, refreshBuckets]);
  
  // Implement other methods for storage operations
  // uploadFile, downloadFile, listFiles, etc.
  
  return {
    buckets: connection.storageBuckets || [],
    selectedBucketId: connection.selectedBucketId,
    selectBucket: (bucketId: string) => updateSupabaseConnection({ selectedBucketId: bucketId }),
    createBucket,
    refreshBuckets,
    isLoading,
    isFetchingBuckets: fetchingBuckets,
  };
}
```

### Step 5: Update the Action Runner

Modify `app/lib/runtime/action-runner.ts` to handle storage actions:

```typescript
// Add to existing handleSupabaseAction method
async handleSupabaseAction(action: SupabaseAction) {
  const { operation, content, filePath, bucketName, fileData, options } = action;
  logger.debug('[Supabase Action]:', { operation, filePath, bucketName });

  switch (operation) {
    // Existing cases...
    
    case 'createBucket':
      this.onSupabaseAlert?.({  
        type: 'info',
        title: 'Supabase Storage',
        description: `Create bucket: ${bucketName}`,
        content: JSON.stringify(options || {}, null, 2),
        source: 'supabase',
        operation: 'storage',
      });
      return { pending: true };
      
    case 'uploadFile':
      this.onSupabaseAlert?.({  
        type: 'info',
        title: 'Supabase Storage',
        description: `Upload file to ${bucketName}: ${filePath}`,
        content: JSON.stringify(options || {}, null, 2),
        source: 'supabase',
        operation: 'storage',
      });
      return { pending: true };
      
    case 'storagePolicy':
      this.onSupabaseAlert?.({  
        type: 'info',
        title: 'Supabase Storage Policy',
        description: `Create policy for bucket: ${bucketName}`,
        content,
        source: 'supabase',
        operation: 'storage',
      });
      
      // Create the migration file
      await this.#runFileAction({
        type: 'file',
        filePath: filePath || `/supabase/migrations/storage_${bucketName}_policy.sql`,
        content,
        changeSource: 'supabase',
      } as any);
      return { success: true };
      
    default:
      throw new Error(`Unknown operation: ${operation}`);
  }
}
```

### Step 6: Create UI Components

1. Create `app/components/chat/SupabaseStorageAlert.tsx`:

```tsx
import React, { useState } from 'react';
import { useStore } from '@nanostores/react';
import { supabaseConnection } from '~/lib/stores/supabase';
import { Button, Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from '~/components/ui';
import { useSupabaseStorage } from '~/lib/hooks/useSupabaseStorage';
import type { SupabaseAlert } from '~/types/actions';

interface SupabaseStorageAlertProps {
  alert: SupabaseAlert;
  onClose: () => void;
}

export default function SupabaseStorageAlert({
  alert,
  onClose,
}: SupabaseStorageAlertProps) {
  const connection = useStore(supabaseConnection);
  const { createBucket, uploadFile } = useSupabaseStorage();
  const [isExecuting, setIsExecuting] = useState(false);
  
  const handleExecute = async () => {
    setIsExecuting(true);
    
    try {
      // Parse the content and determine what operation to perform
      if (alert.operation === 'storage') {
        if (alert.title.includes('Create bucket')) {
          const options = alert.content ? JSON.parse(alert.content) : {};
          const bucketName = alert.description.split('Create bucket: ')[1];
          
          await createBucket(bucketName, options);
        } else if (alert.title.includes('Upload file')) {
          // Handle file upload
          // ...
        }
      }
      
      onClose();
    } catch (error) {
      console.error('Failed to execute storage operation:', error);
    } finally {
      setIsExecuting(false);
    }
  };
  
  return (
    <Dialog open={true} onOpenChange={() => onClose()}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{alert.title}</DialogTitle>
        </DialogHeader>
        <div className="p-4">
          <p className="mb-2">{alert.description}</p>
          {alert.content && (
            <pre className="bg-gray-100 p-2 rounded text-xs overflow-auto max-h-60">
              {alert.content}
            </pre>
          )}
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isExecuting}>
            Cancel
          </Button>
          <Button onClick={handleExecute} disabled={isExecuting || !connection.isConnected}>
            {isExecuting ? 'Executing...' : 'Execute'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

2. Update `app/components/chat/ChatAlert.tsx` to include the storage alert component:

```tsx
// Add to imports
import SupabaseStorageAlert from './SupabaseStorageAlert';

// In the render function, add a condition for storage alerts
{alerts.supabaseAlert && alerts.supabaseAlert.operation === 'storage' && (
  <SupabaseStorageAlert
    alert={alerts.supabaseAlert}
    onClose={() => workbenchStore.clearSupabaseAlert()}
  />
)}
```

### Step 7: Update the Prompt System

1. Create `app/lib/common/prompts/storage.ts` with storage-specific prompts:

```typescript
export const getStorageInstructions = () => `
<storage_instructions>
  The following instructions guide how you should handle file storage operations in projects.
  
  CRITICAL: Use Supabase Storage for file uploads and storage needs unless specified otherwise.
  
  Bucket Management:
    - Create buckets with proper permissions (public or private based on use case)
    - For private buckets, implement Row Level Security (RLS) policies
    - For public buckets, ensure proper file validation to prevent security issues
    - Follow a consistent naming convention for buckets (e.g., 'avatars', 'documents', 'media')
    
  File Upload Best Practices:
    - ALWAYS validate files on the client-side before uploading (type, size, content)
    - CRITICAL: Set appropriate file size limits for buckets
    - ALWAYS specify allowed MIME types for each bucket
    - Generate unique filenames to prevent collisions (UUID + original extension)
    - RECOMMENDED: Store metadata about uploaded files in database tables
    
  Security Considerations:
    - NEVER allow unrestricted file uploads without validation
    - For private files, check user permissions before allowing downloads
    - For image uploads, consider using Supabase's image transformation features
    - ALWAYS handle file upload errors gracefully with user feedback
    
  Implementation Pattern:
    For file operations, follow this pattern:
    
    1. Create appropriate buckets during application initialization
    2. Implement proper RLS policies for buckets
    3. Use the storage client for uploads, downloads, and listing operations
    4. Handle transformations for images when needed
    
  Example Storage Client Setup:
  ```javascript
  // Initialize Supabase client
  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
  const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY
  const supabase = createClient(supabaseUrl, supabaseKey)
  
  // Usage example for uploads
  const { data, error } = await supabase.storage
    .from('avatars')
    .upload('profile-123.png', file, {
      cacheControl: '3600',
      upsert: false,
      contentType: 'image/png'
    })
  ```
  
  File Operations Guidelines:
  - For uploads, always include proper contentType and cacheControl
  - For downloads, use signed URLs for private files
  - For public files, use public URLs with CDN benefits
  - For listing files, paginate results for performance
  
  Storage Bucket Policies:
  - Create SQL migration files for bucket RLS policies
  - Example RLS policy for allowing users to access only their own files:
  
  ```sql
  -- Allow users to select their own files
  CREATE POLICY "Users can view their own files"
    ON storage.objects
    FOR SELECT
    TO authenticated
    USING (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text);
  
  -- Allow users to upload their own files
  CREATE POLICY "Users can upload their own files"
    ON storage.objects
    FOR INSERT
    TO authenticated
    WITH CHECK (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text);
  ```
</storage_instructions>
`;
```

2. Update the main prompt in `app/lib/common/prompts/prompts.ts` to include storage instructions:

```typescript
// Add to imports
import { getStorageInstructions } from './storage';

// In the getSystemPrompt function, add the storage instructions
export const getSystemPrompt = (
  cwd: string = WORK_DIR,
  supabase?: {
    isConnected: boolean;
    hasSelectedProject: boolean;
    credentials?: { anonKey?: string; supabaseUrl?: string };
  },
) => `
  // Existing prompt content...
  
  <database_instructions>
    // Existing database instructions...
  </database_instructions>
  
  ${getStorageInstructions()}
  
  // Rest of the prompt...
`;
```

### Step 8: Update Message Parser for Storage Actions

Modify `app/lib/runtime/message-parser.ts` to recognize storage actions:

```typescript
// In the parseActionTag method, update the supabase action handling
if (type === 'supabase') {
  actionAttributes.type = 'supabase';
  
  // Get the operation attribute
  const operation = node.getAttribute('operation');
  if (!operation) {
    console.warn('Supabase action missing operation attribute');
    return null;
  }
  
  (actionAttributes as SupabaseAction).operation = operation as 
    'migration' | 'query' | 'createBucket' | 'uploadFile' | 'downloadFile' | 'listFiles' | 'storagePolicy';
  
  // Get the bucket name for storage operations
  if (['createBucket', 'uploadFile', 'downloadFile', 'listFiles', 'storagePolicy'].includes(operation)) {
    const bucketName = node.getAttribute('bucket') || node.getAttribute('bucketName');
    if (!bucketName) {
      console.warn(`Supabase ${operation} action missing bucket attribute`);
      return null;
    }
    (actionAttributes as SupabaseAction).bucketName = bucketName;
  }
  
  // For file operations, get the file path
  if (['uploadFile', 'downloadFile', 'storagePolicy'].includes(operation)) {
    const filePath = node.getAttribute('filePath') || node.getAttribute('path');
    if (!filePath) {
      console.warn(`Supabase ${operation} action missing filePath attribute`);
      return null;
    }
    (actionAttributes as SupabaseAction).filePath = filePath;
  }
  
  // For file uploads, get the file data
  if (operation === 'uploadFile') {
    // File data would be in the content of the action tag
    (actionAttributes as SupabaseAction).fileData = textContent.trim();
  }
  
  // For options like public/private, mime types, etc.
  const options = node.getAttribute('options');
  if (options) {
    try {
      (actionAttributes as SupabaseAction).options = JSON.parse(options);
    } catch (e) {
      console.warn('Failed to parse options for Supabase action:', e);
    }
  }
}
```

### Step 9: Update Documentation

Update the changes.md file to record the implementation of Supabase storage:

```markdown
## [2025-05-23] - Add Supabase Storage Bucket Support

**Type:** Feature

**Description:** 
Implemented full support for Supabase storage buckets, allowing applications to create buckets, upload and download files, and manage storage policies. This completes the Supabase integration by supporting both database and storage features.

**Files Affected:**
- app/types/supabase.ts
- app/types/actions.ts
- app/routes/api.supabase.storage.ts
- app/routes/api.supabase.storage.policy.ts
- app/lib/stores/supabase.ts
- app/lib/hooks/useSupabaseStorage.ts
- app/lib/runtime/action-runner.ts
- app/components/chat/SupabaseStorageAlert.tsx
- app/components/chat/ChatAlert.tsx
- app/lib/common/prompts/storage.ts
- app/lib/common/prompts/prompts.ts
- app/lib/runtime/message-parser.ts

**Testing Instructions:**
1. Connect to a Supabase project
2. Create a new bucket using the chat interface
3. Upload files to the bucket
4. Create storage policies for the bucket
5. Test file downloads and listings

**Notes:**
This feature enhances bolt.diy with FULL Supabase support, including storage capabilities essential for modern web applications.
```

### Step 10: Testing and Verification

1. Test bucket creation:
```
User: "Create a new storage bucket called 'images' for storing profile pictures"
```

2. Test file upload:
```
User: "Show me how to upload an image to the 'images' bucket with proper validation"
```

3. Test storage policies:
```
User: "Create a storage policy that only allows users to access their own files"
```
4. Test integration with database:
```
User: "Create a user profile system with avatar uploads and storage"
```

## Supabase Edge Functions, Secrets, and Webhooks Integration

Supabase offers powerful Edge Functions (serverless functions that run at the edge), secure Secrets management, and Webhook support. These features enable building robust backend functionality directly in the Supabase ecosystem without additional infrastructure.

### Edge Functions Overview

Edge Functions are TypeScript/JavaScript functions running on Deno, deployed globally at the edge for low latency responses. They're ideal for:

- API endpoints and microservices
- Webhook handlers (Stripe, GitHub, etc.)
- Custom authentication flows
- Scheduled tasks and data processing
- Third-party API integrations

### Secrets Management

Secure storage for sensitive information (API keys, tokens, etc.) without exposing them in code:

- Project-level secrets accessible by all Edge Functions
- Function-specific secrets for isolated use cases
- Environment-specific secrets (dev/prod separation)

### Webhooks Support

Webhooks allow external services to notify your application when events occur:

- Payment processing with Stripe (future integration)
- Authentication events
- Database change notifications
- Third-party service integrations

### Implementation Plan for bolt.diy

#### 1. Define Types and Interfaces

```typescript
// app/types/supabase.ts - Add these new interfaces

// Edge Function interfaces
export interface SupabaseEdgeFunction {
  id: string;
  name: string;
  slug: string;
  status: 'ACTIVE' | 'INACTIVE';
  version: number;
  created_at: string;
  updated_at: string;
  verify_jwt: boolean;
}

export interface SupabaseSecret {
  name: string;
  value?: string; // Only used when setting, never returned in API responses
}

// Extend existing action types
export interface SupabaseEdgeFunctionAction {
  type: 'supabase';
  operation: 'createEdgeFunction' | 'deployEdgeFunction' | 'invokeEdgeFunction';
  name: string;
  code?: string; // TypeScript/JavaScript code for the function
  verifyJwt?: boolean; // Whether to verify JWT for authentication
}

export interface SupabaseWebhookAction {
  type: 'supabase';
  operation: 'createWebhook' | 'triggerWebhook';
  functionName: string; // Name of the Edge Function to handle the webhook
  service: 'stripe' | 'github' | 'custom'; // Webhook source service
  eventTypes?: string[]; // Event types to listen for (e.g., 'payment_intent.succeeded')
}

export interface SupabaseSecretAction {
  type: 'supabase';
  operation: 'setSecret' | 'deleteSecret';
  name: string;
  value?: string; // Only for setSecret operation
}
```

#### 2. Implement API Endpoints

```typescript
// app/routes/api.supabase.edge-functions.ts
import { json } from '@remix-run/node';
import type { ActionFunction } from '@remix-run/node';

export const action: ActionFunction = async ({ request }) => {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader) {
    return json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  const { token, projectId, operation, name, code, verifyJwt } = await request.json();
  
  // Clean token to remove 'Bearer ' prefix if present
  const cleanToken = token.replace(/^Bearer\s+/i, '');
  
  try {
    // Handle different operations
    switch (operation) {
      case 'list':
        // List Edge Functions
        const listResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/functions`, {
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!listResponse.ok) {
          const error = await listResponse.json();
          return json({ error }, { status: listResponse.status });
        }
        
        const functions = await listResponse.json();
        return json({ functions });
        
      case 'create':
        // Create a new Edge Function
        const createResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/functions`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name,
            verify_jwt: verifyJwt ?? false,
          }),
        });
        
        if (!createResponse.ok) {
          const error = await createResponse.json();
          return json({ error }, { status: createResponse.status });
        }
        
        const createdFunction = await createResponse.json();
        return json({ function: createdFunction });
        
      case 'deploy':
        // Deploy Edge Function code
        if (!code) {
          return json({ error: 'Code is required for deployment' }, { status: 400 });
        }
        
        const deployResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/functions/${name}/deploy`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            code,
            verify_jwt: verifyJwt ?? false,
          }),
        });
        
        if (!deployResponse.ok) {
          const error = await deployResponse.json();
          return json({ error }, { status: deployResponse.status });
        }
        
        const deployedFunction = await deployResponse.json();
        return json({ function: deployedFunction });
        
      default:
        return json({ error: 'Unsupported operation' }, { status: 400 });
    }
  } catch (error) {
    console.error('Error handling Edge Function operation:', error);
    return json({ error: 'Failed to process Edge Function operation' }, { status: 500 });
  }
};
```

```typescript
// app/routes/api.supabase.secrets.ts
import { json } from '@remix-run/node';
import type { ActionFunction } from '@remix-run/node';

export const action: ActionFunction = async ({ request }) => {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader) {
    return json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  const { token, projectId, operation, name, value } = await request.json();
  
  // Clean token to remove 'Bearer ' prefix if present
  const cleanToken = token.replace(/^Bearer\s+/i, '');
  
  try {
    // Handle different operations
    switch (operation) {
      case 'list':
        // List secrets
        const listResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/secrets`, {
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!listResponse.ok) {
          const error = await listResponse.json();
          return json({ error }, { status: listResponse.status });
        }
        
        const secrets = await listResponse.json();
        return json({ secrets });
        
      case 'set':
        // Set a secret
        if (!name || !value) {
          return json({ error: 'Name and value are required for setting a secret' }, { status: 400 });
        }
        
        const setResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/secrets`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name,
            value,
          }),
        });
        
        if (!setResponse.ok) {
          const error = await setResponse.json();
          return json({ error }, { status: setResponse.status });
        }
        
        return json({ success: true, message: `Secret '${name}' set successfully` });
        
      case 'delete':
        // Delete a secret
        if (!name) {
          return json({ error: 'Name is required for deleting a secret' }, { status: 400 });
        }
        
        const deleteResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/secrets/${name}`, {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!deleteResponse.ok) {
          const error = await deleteResponse.json();
          return json({ error }, { status: deleteResponse.status });
        }
        
        return json({ success: true, message: `Secret '${name}' deleted successfully` });
        
      default:
        return json({ error: 'Unsupported operation' }, { status: 400 });
    }
  } catch (error) {
    console.error('Error handling secret operation:', error);
    return json({ error: 'Failed to process secret operation' }, { status: 500 });
  }
};
```

```typescript
// app/routes/api.supabase.webhooks.ts
import { json } from '@remix-run/node';
import type { ActionFunction } from '@remix-run/node';

export const action: ActionFunction = async ({ request }) => {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader) {
    return json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  const { token, projectId, operation, functionName, service, eventTypes } = await request.json();
  
  // Clean token to remove 'Bearer ' prefix if present
  const cleanToken = token.replace(/^Bearer\s+/i, '');
  
  try {
    // Handle different operations
    switch (operation) {
      case 'create':
        // Create a webhook configuration
        if (!functionName || !service) {
          return json({ error: 'Function name and service are required' }, { status: 400 });
        }
        
        // The implementation will depend on the specific service
        // For demonstration, we'll use a generic approach
        const createResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/webhooks`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            function_name: functionName,
            service,
            event_types: eventTypes || ['*'],
          }),
        });
        
        if (!createResponse.ok) {
          const error = await createResponse.json();
          return json({ error }, { status: createResponse.status });
        }
        
        const webhook = await createResponse.json();
        return json({ webhook });
        
      case 'list':
        // List webhooks
        const listResponse = await fetch(`https://api.supabase.com/v1/projects/${projectId}/webhooks`, {
          headers: {
            Authorization: `Bearer ${cleanToken}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!listResponse.ok) {
          const error = await listResponse.json();
          return json({ error }, { status: listResponse.status });
        }
        
        const webhooks = await listResponse.json();
        return json({ webhooks });
        
      default:
        return json({ error: 'Unsupported operation' }, { status: 400 });
    }
  } catch (error) {
    console.error('Error handling webhook operation:', error);
    return json({ error: 'Failed to process webhook operation' }, { status: 500 });
  }
};
```

#### 3. Create Custom React Hooks

```typescript
// app/lib/hooks/useSupabaseEdgeFunctions.ts
import { useState } from 'react';
import { useSupabaseConnection } from './useSupabaseConnection';
import type { SupabaseEdgeFunction } from '../../types/supabase';

export function useSupabaseEdgeFunctions() {
  const { connection } = useSupabaseConnection();
  const [functions, setFunctions] = useState<SupabaseEdgeFunction[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const listFunctions = async () => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/edge-functions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'list',
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to list Edge Functions');
      }

      const data = await response.json();
      setFunctions(data.functions || []);
    } catch (err) {
      setError(err.message || 'An error occurred while listing Edge Functions');
    } finally {
      setLoading(false);
    }
  };

  const createFunction = async (name: string, verifyJwt: boolean = false) => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return null;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/edge-functions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'create',
          name,
          verifyJwt,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to create Edge Function');
      }

      const data = await response.json();
      await listFunctions(); // Refresh the list
      return data.function;
    } catch (err) {
      setError(err.message || 'An error occurred while creating Edge Function');
      return null;
    } finally {
      setLoading(false);
    }
  };

  const deployFunction = async (name: string, code: string, verifyJwt: boolean = false) => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return null;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/edge-functions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'deploy',
          name,
          code,
          verifyJwt,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to deploy Edge Function');
      }

      const data = await response.json();
      await listFunctions(); // Refresh the list
      return data.function;
    } catch (err) {
      setError(err.message || 'An error occurred while deploying Edge Function');
      return null;
    } finally {
      setLoading(false);
    }
  };

  return {
    functions,
    loading,
    error,
    listFunctions,
    createFunction,
    deployFunction,
  };
}
```

```typescript
// app/lib/hooks/useSupabaseSecrets.ts
import { useState } from 'react';
import { useSupabaseConnection } from './useSupabaseConnection';
import type { SupabaseSecret } from '../../types/supabase';

export function useSupabaseSecrets() {
  const { connection } = useSupabaseConnection();
  const [secrets, setSecrets] = useState<SupabaseSecret[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const listSecrets = async () => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/secrets', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'list',
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to list secrets');
      }

      const data = await response.json();
      setSecrets(data.secrets || []);
    } catch (err) {
      setError(err.message || 'An error occurred while listing secrets');
    } finally {
      setLoading(false);
    }
  };

  const setSecret = async (name: string, value: string) => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return false;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/secrets', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'set',
          name,
          value,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to set secret');
      }

      await listSecrets(); // Refresh the list
      return true;
    } catch (err) {
      setError(err.message || 'An error occurred while setting secret');
      return false;
    } finally {
      setLoading(false);
    }
  };

  const deleteSecret = async (name: string) => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return false;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/secrets', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'delete',
          name,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to delete secret');
      }

      await listSecrets(); // Refresh the list
      return true;
    } catch (err) {
      setError(err.message || 'An error occurred while deleting secret');
      return false;
    } finally {
      setLoading(false);
    }
  };

  return {
    secrets,
    loading,
    error,
    listSecrets,
    setSecret,
    deleteSecret,
  };
}
```

```typescript
// app/lib/hooks/useSupabaseWebhooks.ts
import { useState } from 'react';
import { useSupabaseConnection } from './useSupabaseConnection';

interface Webhook {
  id: string;
  function_name: string;
  service: string;
  event_types: string[];
  created_at: string;
}

export function useSupabaseWebhooks() {
  const { connection } = useSupabaseConnection();
  const [webhooks, setWebhooks] = useState<Webhook[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const listWebhooks = async () => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/webhooks', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'list',
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to list webhooks');
      }

      const data = await response.json();
      setWebhooks(data.webhooks || []);
    } catch (err) {
      setError(err.message || 'An error occurred while listing webhooks');
    } finally {
      setLoading(false);
    }
  };

  const createWebhook = async (functionName: string, service: string, eventTypes: string[] = ['*']) => {
    if (!connection.token || !connection.project) {
      setError('No active Supabase connection');
      return null;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/supabase/webhooks', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.token}`,
        },
        body: JSON.stringify({
          token: connection.token,
          projectId: connection.project.id,
          operation: 'create',
          functionName,
          service,
          eventTypes,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to create webhook');
      }

      const data = await response.json();
      await listWebhooks(); // Refresh the list
      return data.webhook;
    } catch (err) {
      setError(err.message || 'An error occurred while creating webhook');
      return null;
    } finally {
      setLoading(false);
    }
  };

  return {
    webhooks,
    loading,
    error,
    listWebhooks,
    createWebhook,
  };
}
```

#### 4. Update Action Runner

```typescript
// app/lib/actions/action-runner.ts - Update the handleSupabaseAction method

handleSupabaseAction = async (action: SupabaseAction) => {
  const { operation } = action;
  
  // Create reference to user alert for this action
  const alertId = this.#createSupabaseAlert(action);
  
  try {
    switch (operation) {
      case 'migration':
        // Existing migration code...
        break;
        
      case 'query':
        // Existing query code...
        break;
        
      // Add new case handlers for Edge Functions
      case 'createEdgeFunction':
        const { name, verifyJwt } = action as SupabaseEdgeFunctionAction;
        // Show message to user
        this.#updateSupabaseAlert(alertId, {
          message: `Creating Edge Function: ${name}`,
          status: 'running',
        });
        
        // Call API to create Edge Function
        const createResult = await this.#supabaseApi.createEdgeFunction(name, verifyJwt);
        
        this.#updateSupabaseAlert(alertId, {
          message: `Edge Function ${name} created successfully`,
          status: 'success',
        });
        break;
        
      case 'deployEdgeFunction':
        const { name: funcName, code, verifyJwt: verify } = action as SupabaseEdgeFunctionAction;
        
        this.#updateSupabaseAlert(alertId, {
          message: `Deploying Edge Function: ${funcName}`,
          status: 'running',
        });
        
        // Write code to file first (following pattern for migrations)
        const filePath = `/supabase/functions/${funcName}/index.ts`;
        await this.#runFileAction({
          type: 'file',
          filePath,
          content: code || '',
          changeSource: 'supabase',
        });
        
        // Call API to deploy Edge Function
        const deployResult = await this.#supabaseApi.deployEdgeFunction(funcName, code || '', verify);
        
        this.#updateSupabaseAlert(alertId, {
          message: `Edge Function ${funcName} deployed successfully`,
          status: 'success',
        });
        break;
        
      // Add case handlers for Secrets
      case 'setSecret':
        const { name: secretName, value } = action as SupabaseSecretAction;
        
        this.#updateSupabaseAlert(alertId, {
          message: `Setting secret: ${secretName}`,
          status: 'running',
        });
        
        const setSecretResult = await this.#supabaseApi.setSecret(secretName, value || '');
        
        this.#updateSupabaseAlert(alertId, {
          message: `Secret ${secretName} set successfully`,
          status: 'success',
        });
        break;
        
      // Add case handler for Webhooks
      case 'createWebhook':
        const { functionName, service, eventTypes } = action as SupabaseWebhookAction;
        
        this.#updateSupabaseAlert(alertId, {
          message: `Creating webhook for ${service} using ${functionName}`,
          status: 'running',
        });
        
        const createWebhookResult = await this.#supabaseApi.createWebhook(functionName, service, eventTypes);
        
        this.#updateSupabaseAlert(alertId, {
          message: `Webhook for ${service} created successfully`,
          status: 'success',
        });
        break;
        
      default:
        this.#updateSupabaseAlert(alertId, {
          message: `Unsupported Supabase operation: ${operation}`,
          status: 'error',
        });
    }
  } catch (error) {
    this.#updateSupabaseAlert(alertId, {
      message: `Error performing Supabase ${operation}: ${error.message}`,
      status: 'error',
    });
  }
};
```

#### 5. Update Prompt System

```typescript
// app/lib/common/prompts/prompts.ts - Add to the Supabase section

// Add to the existing Supabase section
const supabasePrompts = `
// ... existing content ...

## Edge Functions

Supabase Edge Functions are server-side TypeScript/JavaScript functions that run at the edge, close to your users. They are ideal for handling webhooks, custom API endpoints, and server-side operations.

### Creating and Deploying Edge Functions

To create a new Edge Function:

\`\`\`typescript
<boltAction type="supabase" operation="createEdgeFunction" name="stripe-webhook" verifyJwt={false}>
\`\`\`

To deploy an Edge Function with code:

\`\`\`typescript
<boltAction type="supabase" operation="deployEdgeFunction" name="stripe-webhook" verifyJwt={false}>
import { serve } from 'https://deno.land/std@0.182.0/http/server.ts';
import { stripe } from 'https://esm.sh/stripe@11.11.0';

const stripeClient = new stripe(Deno.env.get('STRIPE_SECRET_KEY') || '');
const webhookSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET') || '';

serve(async (req) => {  
  const signature = req.headers.get('stripe-signature');
  if (!signature) {
    return new Response('No signature provided', { status: 400 });
  }
  
  try {
    const body = await req.text();
    const event = stripeClient.webhooks.constructEvent(body, signature, webhookSecret);
    
    // Handle the event
    switch (event.type) {
      case 'payment_intent.succeeded':
        // Handle successful payment
        break;
      // Add other event handlers as needed
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
    
    return new Response(JSON.stringify({ received: true }), {
      headers: { 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (err) {
    return new Response(`Webhook Error: ${err.message}`, { status: 400 });
  }
});
</boltAction>
\`\`\`

### Managing Secrets

Secrets are environment variables accessible to your Edge Functions:

\`\`\`typescript
<boltAction type="supabase" operation="setSecret" name="STRIPE_SECRET_KEY" value="sk_test_...">  
</boltAction>
\`\`\`

### Setting Up Webhooks

Webhooks allow external services to notify your application when events occur:

\`\`\`typescript
<boltAction type="supabase" operation="createWebhook" functionName="stripe-webhook" service="stripe" eventTypes={['payment_intent.succeeded', 'payment_intent.failed']}>
</boltAction>
\`\`\`

### Best Practices for Edge Functions

1. **Security First**: Always validate webhook signatures for services like Stripe to prevent unauthorized requests.
2. **Error Handling**: Implement comprehensive error handling and return appropriate HTTP status codes.
3. **Environment Variables**: Use Supabase Secrets for sensitive information, never hardcode them.
4. **Logging**: Add proper logging for debugging but avoid logging sensitive information.
5. **Timeouts**: Keep functions efficient as they have execution time limits.
6. **Stripe Integration**: For payment processing, always verify webhook signatures, handle idempotency, and implement proper error handling.

Example of a complete Stripe webhook handler:

\`\`\`typescript
<boltAction type="supabase" operation="deployEdgeFunction" name="stripe-webhook" verifyJwt={false}>
import { serve } from 'https://deno.land/std@0.182.0/http/server.ts';
import { stripe } from 'https://esm.sh/stripe@11.11.0';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.23.0';

// Initialize Stripe
const stripeClient = new stripe(Deno.env.get('STRIPE_SECRET_KEY') || '');
const webhookSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET') || '';

// Initialize Supabase client
const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
const supabase = createClient(supabaseUrl, supabaseKey);

serve(async (req) => {  
  // Verify request is POST and has correct content type
  if (req.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 });
  }
  
  const signature = req.headers.get('stripe-signature');
  if (!signature) {
    return new Response('No signature provided', { status: 400 });
  }
  
  try {
    // Get request body as text
    const body = await req.text();
    
    // Verify Stripe signature
    const event = stripeClient.webhooks.constructEvent(body, signature, webhookSecret);
    
    // Handle different event types
    switch (event.type) {
      case 'payment_intent.succeeded':
        const paymentIntent = event.data.object;
        
        // Update database with payment information
        const { data, error } = await supabase
          .from('payments')
          .insert({
            payment_id: paymentIntent.id,
            customer_id: paymentIntent.customer,
            amount: paymentIntent.amount,
            currency: paymentIntent.currency,
            status: paymentIntent.status,
            payment_method: paymentIntent.payment_method_types[0],
            created_at: new Date().toISOString(),
          });
          
        if (error) {
          console.error('Error recording payment:', error);
          // Still return 200 to Stripe as we received the webhook
        }
        break;
        
      case 'customer.subscription.created':
      case 'customer.subscription.updated':
        const subscription = event.data.object;
        
        // Update subscription info in database
        const { data: subData, error: subError } = await supabase
          .from('subscriptions')
          .upsert({
            subscription_id: subscription.id,
            customer_id: subscription.customer,
            status: subscription.status,
            current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
            price_id: subscription.items.data[0].price.id,
            updated_at: new Date().toISOString(),
          }, {
            onConflict: 'subscription_id'
          });
          
        if (subError) {
          console.error('Error updating subscription:', subError);
        }
        break;
        
      // Handle more event types as needed
      
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
    
    return new Response(JSON.stringify({ received: true }), {
      headers: { 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (err) {
    console.error('Webhook error:', err);
    return new Response(`Webhook Error: ${err.message}`, { status: 400 });
  }
});
</boltAction>
\`\`\`
`;
```

#### 6. Implementation Summary

To fully integrate Supabase Edge Functions, Secrets, and Webhooks in bolt.diy, we should implement the following components:

1. **Types & Interfaces**: Define SupabaseEdgeFunction, SupabaseSecret, and appropriate action interfaces
2. **API Endpoints**: Create endpoints for managing edge functions, secrets, and webhooks
3. **React Hooks**: Implement hooks for interacting with these API endpoints
4. **Action Runner**: Update to handle new action types
5. **UI Components**: Add UI for managing edge functions, secrets, and webhooks
6. **Prompt System**: Add documentation and examples for developers

#### 7. Stripe Integration Preparation

For future Stripe integration, we've included:

1. **Webhook Handler Template**: Complete example of Stripe webhook handling
2. **Security Best Practices**: Signature validation, error handling, and database operations
3. **Event Type Handling**: Payment intents and subscription management examples

This implementation lays the groundwork for Stripe payment processing, subscription management, and customer data handling within the bolt.diy framework.
